<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-360e1db7-4ed4-418c-8cc7-f6693cdaa464"></attachment><p>预处理(.i)-&gt;编译(.s)-&gt;汇编(.o)-&gt;链接</p><p>-E -S -c -o</p><p>gcc -E <em>.c -o </em>.i</p><p>gcc -S <em>.i -o </em>.s</p><p>gcc -c *.s</p><p>gcc *.o</p><p><br></p><p>静态库 .o:</p><p>g++ -c st1.cpp st2.cpp</p><p>ar -crv libmytest.a st1.o st2.o </p><p>g++ -o run main.cpp -L./ -lmytest (g++ main.cpp -o main -static libmytest.a)</p><p><br></p><p>动态库 .so: </p><p>g++ test<em>1.cpp test</em>2.cpp test<em>3.cpp -fPIC -shared -o libtest.so (g++</em></p><p>g++ main.cpp -o run -L. -ltest (g++ main.cpp -o run  -shared libtest.so )</p><p>ldd a.out 查看动态库是否可以找的到</p><p> LD<em>LIBRARY</em>PATH 将动态库加入到环境变量或者添加到/etc/ld.so.conf ./run linux下所有的动态库位置都在/etc/ld.so.conf中记录，可以自己查看添加，最后使用ldconfig来重新加载 </p><p>========================</p><p> -fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)， 则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意 位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。 gcc -shared -fPIC -o 1.so 1.c 这里有一个-fPIC参数 PIC就是position independent code PIC使.so文件的代码段变为真正意义上的共享 如果不加-fPIC,则加载.so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的copy.每个copy都不一样,取决于 这个.so文件代码段和数据段内存映射的位置. 不加fPIC编译出来的so,是要再加载时根据加载到的位置再次重定位的.(因为它里面的代码并不是位置无关代码) 如果被多个应用程序共同使用,那么它们必须每个程序维护一份so的代码副本了.(因为so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享) 我们总是用fPIC来生成so,也从来不用fPIC来生成a. fPIC与动态链接可以说基本没有关系,libc.so一样可以不用fPIC编译,只是这样的so必须要在加载到用户程序的地址空间时重定向所有表目.</p><p><br></p>